//
// OpenTissue, A toolbox for physical based simulation and animation.
// Copyright (C) 2007 Department of Computer Science, University of Copenhagen
//
#include <OpenTissue/configuration.h>

#include <OpenTissue/graphics/core/gl/gl_util.h>

#if defined(WIN32)
#  define NOMINMAX
#  define WIN32_LEAN_AND_MEAN
#  include <windows.h> // needed for MovieMaker
#  undef WIN32_LEAN_AND_MEAN
#  undef NOMINMAX
#  include <misc/MovieMaker.h>
#  include <sstream>
#else
#  include <unistd.h>  // for sleep()
#endif

#include <OpenTissue/math/degree.h>
#include <OpenTissue/math/highest.h>
#include <OpenTissue/math/lowest.h>
#include <OpenTissue/math/pi.h>


#include <OpenTissue/image/image.h>
#include <OpenTissue/image/util/screen_capture.h>
#include <OpenTissue/image/io/image_write.h>
#include <OpenTissue/trackball/trackball.h>

#include <iostream>
#include <iomanip>


////////////////////////////////////////////////////////////////////////////////

GLdouble eyex = 0;
GLdouble eyey = 0.2;
GLdouble eyez = 2;
GLdouble centerx = 0;
GLdouble centery = 0.2;
GLdouble centerz = 0;
GLdouble upx = 0;
GLdouble upy = 1;
GLdouble upz = 0;

GLdouble fovy   = 30;
GLdouble aspect = 1.0;
GLdouble zNear = 0.001;
GLdouble zFar  = 5000;

//int winWidth  = 1024;
//int winHeight = 768;
int winWidth  = 800;
int winHeight = 600;
//int winWidth  = 640;
//int winHeight = 480;
//int winWidth  = 320;
//int winHeight = 240;


bool bZoomModeOn = false;
GLdouble zoomSensitivity = 0.01;
bool bPanModeOn = false;
GLdouble panSensitivity = 0.001;
int xPixelCoord;
int yPixelCoord;
int yScale;
bool bPanObstacle = false;
bool bScaleObstacle = false;
double xPan, yPan, zPan;

bool bTrackballModeOn = false;

OpenTissue::Trackball<> trackball(1.0);


// Support for movie capture using Nvidia SDK
#ifdef WIN32
static MovieMaker *pMovie = NULL;
bool bMovieOn = false;
#endif

int mainWindow = 0;   ///< Identification of main window, used by main method and clean-exit method.
bool idleOn = false;  ///< Boolean flag to indicate if the idle() function is running.
bool screenCapture = false; ///< Boolean flag indicating if screen capture should be done or not.
bool draw_normals = false;
bool draw_surface = false;
bool draw_inside = false;
bool draw_velocity = false;
bool osd = true;
bool render = false;
int obstacles = 0;
bool use_emitter = false;
bool waves = false;
//unsigned long test_pars = 0;

////////////////////////////////////////////////////////////////////////////////

#undef DRAW_KERNELS
//#define DRAW_KERNELS

//#define USE_GAUSSIAN

#define SPHSH
//#define SPHSH_PARALLEL

#include <OpenTissue/utility/fps_counter.h>
#include <OpenTissue/math/vector3.h>
#include <OpenTissue/utility/runtime_type.h>
#include <OpenTissue/dynamics/cfd/sph/sph.h>
#include <OpenTissue/map/map.h>
#include <OpenTissue/map/util/grid_idx2coord.h>
#include <OpenTissue/mesh/mesh.h>
#include <OpenTissue/t4mesh/t4mesh.h>
#include <OpenTissue/t4mesh/util/thin_shell/thin_shell.h>
#include <OpenTissue/t4mesh/io/t4mesh_xml_read.h>
#include <OpenTissue/t4mesh/io/t4mesh_xml_write.h>
#include <OpenTissue/collision/spatial_hashing/spatial_hashing.h>
#include <OpenTissue/geometry/capsule.h>
#include <OpenTissue/geometry/sphere.h>
#include <OpenTissue/geometry/obb.h>

#include <vector>
#include <list>
#include <cmath>
#include <string>


using namespace std;
using namespace OpenTissue;


template<typename Point_Type>
class T4NodeTraits
{
public:
  typedef Point_Type  point_type;
  inline const point_type& vertex() const {return *m_vertex;}
  const point_type*  m_vertex;
};

typedef RuntimeType<double>  RTreal;
RTreal Radius;
typedef Math::BasicMathTypes<double,size_t> math_types;


typedef math_types::vector3_type      point;
typedef math_types::vector3_type      vector3_type;
typedef math_types::real_type         real_type;
typedef vector<point>                 point_container;
typedef t4mesh::T4Mesh<math_types, T4NodeTraits<point> > tetrahedra_mesh;
typedef OpenTissue::SPHParticle<real_type, OpenTissue::vector3, &Radius>  Particle;

typedef ShapeBase<math_types> Volume;
typedef Capsule<math_types>   CapsuleObj;
typedef Sphere<math_types>    SphereObj;
typedef OBB<math_types>       BoxObj;

typedef OpenTissue::ImplicitSpherePrimitive<real_type, OpenTissue::vector3<real_type>, SphereObj> ImplicitSphere;
typedef OpenTissue::ImplicitCapsulePrimitive<real_type, OpenTissue::vector3<real_type>, CapsuleObj> ImplicitCapsule;
typedef OpenTissue::ImplicitPlanePrimitive<real_type, OpenTissue::vector3<real_type> > ImplicitPlane;
//typedef OpenTissue::ImplicitBoxPrimitive<real_type, OpenTissue::vector3<real_type> > ImplicitBox;
typedef OpenTissue::ImplicitBoxPrimitive<real_type, OpenTissue::vector3<real_type>, BoxObj> ImplicitBox;

//typedef OpenTissue::CollisionTypeBinder<real_type, OpenTissue::vector3> CollisionTypes;
//typedef OpenTissue::ParticleWrapper<point, Particle> Particle_Wrapper;
//typedef OpenTissue::TetrahedronWrapper<real_type, point, tetrahedra_mesh::tetrahedron_type> Tetrahedron_Wrapper;
//typedef OpenTissue::TetrahedraPointsCollisionDetectionPolicy<CollisionTypes, Tetrahedron_Wrapper, Particle_Wrapper> CollisionDetection;
typedef OpenTissue::TetrahedraPointsCollisionDetectionPolicy<real_type, OpenTissue::vector3, tetrahedra_mesh::tetrahedron_type, Particle> T4CollisionDetection;
typedef OpenTissue::ImplicitPrimitivesCollisionDetectionPolicy<real_type, OpenTissue::vector3<double>, Particle> IPCollisionDetection;

typedef SPHTypeBinder< real_type,
                       unsigned long,
                       std::string,
                       OpenTissue::vector3,
                       Particle,

                       //T4CollisionDetection,
                       IPCollisionDetection,

                       //OpenTissue::GridHashFunction,
                       OpenTissue::PrimeNumberHashFunction,

                       OpenTissue::HashGrid,
                       OpenTissue::PointDataQuery
                     > SPHTypes;

#if defined(SPHSH)
const bool rangeCheck = false;
#else
const bool rangeCheck = true;
#endif

//typedef WGaussian<SPHTypes, &Radius> KernelGaussian;
typedef WFixedGaussian<SPHTypes, &Radius, rangeCheck> KernelGaussian;
typedef WPoly6<SPHTypes, &Radius, rangeCheck> KernelDefault;
typedef WSpiky<SPHTypes, &Radius, rangeCheck> KernelPressure;
typedef WViscosity<SPHTypes, &Radius, rangeCheck> KernelViscosity;

#ifdef USE_GAUSSIAN
  typedef SPHDensity<SPHTypes, KernelGaussian> DensitySolver;
  typedef SPHSurfaceNormal<SPHTypes, KernelGaussian> NormalSolver;
  typedef SPHPressureForce<SPHTypes, KernelGaussian> PressureForce;
  typedef SPHViscosityForce<SPHTypes, KernelGaussian> ViscosityForce;
  typedef SPHSurfaceForce<SPHTypes, KernelGaussian> SurfaceForce;
  typedef SPHColorField<SPHTypes, KernelGaussian> ColorField;
#else
  typedef SPHDensity<SPHTypes, KernelDefault> DensitySolver;
  typedef SPHSurfaceNormal<SPHTypes, KernelDefault> NormalSolver;
  typedef SPHPressureForce<SPHTypes, KernelPressure> PressureForce;
  typedef SPHViscosityForce<SPHTypes, KernelViscosity> ViscosityForce;
  typedef SPHSurfaceForce<SPHTypes, KernelDefault> SurfaceForce;
  typedef SPHColorField<SPHTypes, KernelDefault> ColorField;
#endif
typedef SPHPressure<SPHTypes> PressureSolver;
typedef SPHGravity<SPHTypes> GravityForce;
typedef SPHBuoyancy<SPHTypes> BuoyancyForce;

typedef SPHVerlet<SPHTypes> VerletIntegrator;
typedef SPHEuler<SPHTypes> EulerIntegrator;
typedef SPHLeapFrog<SPHTypes> LeapFrogIntegrator;

typedef SPHWater<SPHTypes> WaterMaterial;
typedef SPHMucus<SPHTypes> MucusMaterial;
typedef SPHSteam<SPHTypes> SteamMaterial;

typedef SPHPointEmitter<SPHTypes> PointEmitter;
typedef SPHCircleEmitter<SPHTypes> CircleEmitter;


typedef SPHSystem<SPHTypes,
                  DensitySolver,
                  PressureSolver,
                  NormalSolver,
                  GravityForce,
                  BuoyancyForce,
                  PressureForce,
                  ViscosityForce,
                  SurfaceForce,
                  LeapFrogIntegrator,//EulerIntegrator,//VerletIntegrator,//
                  ColorField> DefaultSystem;


DefaultSystem* sph = NULL;
SPHMaterial<SPHTypes>* material = NULL;
//IsoSurface surface;
Map<double,math_types>  phi;
polymesh::PolyMesh<> surface;

FPSCounter<double> fps;
point_container points;
tetrahedra_mesh shell;
SphereObj sphere(vector3_type(0,0,0.1), 0.25);
SphereObj sphere2(vector3_type(0,0,-0.2), 0.25);
//BoxObj box(vector3_type(-0.0625,-0.0625,-0.0625), diag(1.), vector3_type(0.1875,0.1875,0.1875));
BoxObj box(vector3_type(0.0,0.0,0.0), diag(1.), vector3_type(0.1875,0.1875,0.1875));
ImplicitSphere isphere(sphere);
ImplicitSphere isphere2(sphere2);
CapsuleObj capsule(vector3_type(0.0,0.0,0.0), vector3_type(0.0,0.0,0.6), 0.2);
ImplicitCapsule icapsule(capsule);
ImplicitPlane iplane(vector3_type(0,0,-2.0), vector3_type(0,0,1.0));
//ImplicitBox ibox(vector3_type(-0.25,-0.25,-0.25), vector3_type(0.125,0.125,0.125));
ImplicitBox ibox(box);
PointEmitter emitter1(vector3_type(0,0,0), vector3_type(-1.5,0,.5));
CircleEmitter emitter2( vector3_type(0.0), 0.015, vector3_type(0.0,0.0,1.5));
CircleEmitter emitter3(vector3_type(0,0,0.7), 0.02, vector3_type(0,0,-1));


BoxObj DBb1(vector3_type(0.0,0.0,0.0), diag(1.), vector3_type(0.1875,0.1,0.4));
BoxObj DBb2(vector3_type(0.3125,0.0,0.0), diag(1.), vector3_type(0.5,0.1,0.4));
BoxObj DBb3(vector3_type(0.0,0.0,0.0), diag(1.), vector3_type(0.5,0.1,0.4));
ImplicitBox iDBb1(DBb1);
ImplicitBox iDBb2(DBb2);

SPHEmitter<SPHTypes> *emitter = &emitter2;
//SPHEmitter<SPHTypes> *emitter = &emitter3;
Volume* object = &capsule;

void addCollisionObject(Volume* obj)
{
  object = obj;
  if (sph) {
    if (object == &capsule)
      sph->collisionSystem().addContainer(icapsule);
    else if (object == &sphere)
      sph->collisionSystem().addContainer(isphere);
    else if (object == &box)
      sph->collisionSystem().addContainer(ibox);
    else if (object == &DBb1)
      sph->collisionSystem().addContainer(iDBb1);
    else if (object == &DBb2)
      sph->collisionSystem().addContainer(iDBb2);
  }
}

/**
  //--- KE 27-01-2005: A quick and dirty search on google:
  //---
  //---  http://scienceworld.wolfram.com/physics/UniversalGasConstant.html
  //---  http://www.science.uwaterloo.ca/~cchieh/cact/c123/liquid.html
  //---  http://www.thermexcel.com/english/tables/eau_atm.htm
  //---
  //--- in metric system  Newton, kilogram, meters, seconds... then
  //---
  //---  density = 1000 Kg/m^3     viscosity = 0.001 N s/ m^{-2}
  //---  gas constant = 8,314510   J/(mol K)
  //---
  //--- Say we have a box of 2mx2mx2m=8m3, and one eight is filled
  //--- with water 1x1x1 m3, then we have 1000Kg of water.
  //--- Say we want to represent this water uniformly with 500 particles, then
  //--- each particle should rougly represent 2 Kg of water (big particle:-)
  //---
  //--- Ideal gas behaves according to:
  //---
  //---   P V = n R T
  //---
  //--- T måles i K (Kelvin)
  //--- n er antal mol
  //--- R er gas konstanten
  //--- P er trykket (N/m^2)
  //--- V er volume (m^3)
  //---
  //--- Kraft måles i Newton, 1 N = 1 Kg m/s^2, så heraf ses at
  //---
  //---  P V ~  N/m^2 * m^3 = N m
  //---
  //--- højresiden er så
  //---
  //---    n R T = mol ( J/(mol K)) K = J
  //---
  //--- så heraf ser vi   J = N m og faktisk er
  //---
  //---    J = Kg m^2 / s^2   = N m ....aha det var dejligt:-)
  //---
  //--- Den molare volume af vand er
  //---
  //---    V_m  = 0.000055 m^3 / mol
  //---
  //--- Vands molare masse
  //---
  //---    m_m  =  0.018 Kg/mol
  //---
  //--- Givet rumfang V (m^3) af en mængde vand
  //---
  //---    V/V_m  = n  (mol)
  //---
  //--- Massen af V mængde vand er derfor
  //---
  //---    n * n_m  = M  (Kg)
  //---
  //--- Antallet af molekyler i n mol vand
  //---
  //---   n * Na  =  N molekyler     (hvor Na = 6.0221367 10^23 1/mol er Avogadros tal, angiver antal molekyler per mol)
  //---
  //--- Okay, så hvad er den gennemsnitlige afstand i mellem vand-molekylerne? Hmm et molekyle fylder
  //---
  //---   dV = V/N
  //---
  //--- Så en gennemsnnitlig radius er
  //---
  //---   r =  ^3sqrt{ dV }  / 2    // altså cubic-rodden
  //---
  //--- Hvad kan man så bruge det til????
  //---
  //---   Det giver vel en ide om hvilke strrelses ordner du skal op i for at simulere en givet mængde vand nogenlunde naturtro???
  //---
 */
template<typename MaterialPolicy>
bool createFluid(const SPHTypes::ulong& particles)
{
  delete material;
  delete sph;

  material = new MaterialPolicy;
  material->particles() = particles;
  material->particle_mass(material->particle_mass());
//  material->volume(0.1);
//  material->particle_mass(0.024);

//  const SPHTypes::real_type  x = 20;         //--- Average number of particles inside kernel...
//  const SPHTypes::real_type  x = material->density()*material->particle_mass();         //--- Average number of particles inside kernel...
  const SPHTypes::real_type  x = material->kernel_particles();         //--- Average number of particles inside kernel...

  material->threshold() = material->density()/x;
//  material->threshold() = material->volume()/x;
//    material->threshold() = 1000*material->volume()/x;
//    material->threshold() *= material->threshold();
//  material->threshold() = 4;

  Radius = material->radius(x);
  vector3_type gravity(0,0,-9.82);
//  vector3_type gravity(0,0,-0.1);
//  vector3_type gravity(0,0,0);

  sph = new DefaultSystem;

  if (!sph->create(
       *static_cast< MaterialPolicy* >(material), gravity)
     )  // material, gravity
    return false;

//  if (!sph->initHashing(static_cast<DefaultSystem::size_type>(2*particles), 2*Radius))  // hash table size, cell spacing (AABBs)
  if (!sph->initHashing(static_cast<DefaultSystem::size_type>(2*particles), Radius))  // hash table size, cell spacing (AABBs)
    return 0;
#if 0
  sph->collisionSystem().addObstacle(shell.tetrahedron_begin(),  shell.tetrahedron_end());
#else
  addCollisionObject(object);
//  sph->collisionSystem().addContainer(isphere); object = &sphere;
//  sph->collisionSystem().addObstacle(isphere2);
//  sph->collisionSystem().addContainer(icapsule); object = &capsule;
//  sph->collisionSystem().addObstacle(iplane);
//  sph->collisionSystem().addObstacle(ibox); object = &box;
//  sph->collisionSystem().addContainer(ibox); object = &box;
//  sph->collisionSystem().addContainer(iDBb1); object = &DBb1;
//  sph->collisionSystem().addContainer(iDBb2); object = &DBb2;

#endif

  if (use_emitter) {
//    emitter = &emitter;
    emitter = &emitter2;
//    emitter = &emitter3;
    emitter->batch() = 5;//7
    emitter->rate() = 2;

    if (!sph->init(emitter2, particles))
      return false;
  }
  else {
    emitter = NULL;
    typedef std::vector<vector3_type> vectors;
    vectors positions, velocities;

    const SPHTypes::real_type dist = 1./45.;
    const SPHTypes::real_type off = -.14;
    SPHTypes::ulong k = 1, j = 1, i = 1, p = particles;
    while (p--) {
      positions.push_back(vector3_type(off+i*dist, off+j*dist, off+k*dist));
      velocities.push_back(vector3_type(0.,0.,0.));
//      velocities.push_back(vector3_type(0.,0.,2.));
      if (++i > 12) {
        i = 1;
        if (++j > 12) {
          j = 1;
          ++k;
        }
      }
    }

    if (!sph->init(positions.begin(), positions.end(),
                    velocities.begin(), velocities.end()))
      return false;
  }

  return true;
}

/**
 * Triangle Mesh to Tetrahedra Mesh conversion
 * - Using the Thin Shell utility
 */
bool TMesh2T4Mesh(const string& in, const string& out)
{
  typedef ThinShellTypeBinder<
      math_types
      , polymesh::PolyMesh<>
    , tetrahedra_mesh
    , AngleWeightedNormals
    //, MaximumGlobalExtrusion
    //, MaximumAdaptiveExtrusion
    , BisectionAdaptiveExtrusion
    //, DepthFirstTesselator
    , RippleTesselator
    > TSTypes;

  typedef ThinShell<TSTypes> ThinShell;
  ThinShell thin_shell;

  shell.clear();

  polymesh::PolyMesh<> mesh;
  if (!mesh::default_read(in, mesh))
  {
    cout << "ERROR: Could not import triangle mesh file \"" << in << "\"" << endl;
    return false;
  }

  vector3<double> minCoord, maxCoord, diff, center;
  mesh::compute_mesh_center(mesh,center);
  center *= -1;
  mesh::translate(mesh,center);

/*
  matrix3x3<real_type> R(1,0,0, 0,0,1, 0,1,0);
  rotate(mesh,R);

  center = 0;
  center[2] = 0.5;
  translate(mesh,center);

mesh::compute_mesh_maximum_coord(mesh,maxCoord);
mesh::compute_mesh_minimum_coord(mesh,minCoord);
  diff = maxCoord - minCoord;
  double extent = std::max(std::max(diff[0], diff[1]), diff[2]);
  double scale = 1. / extent;
  uniform_scale(mesh,scale);
*/

  double thickness = -0.5;
  thin_shell.run(mesh, thickness, shell, points);
  if (!t4mesh::xml_write(out, shell, points)) {
    cout << "ERROR: Could not export tetrahedra mesh file \"" << out << "\"" << endl;
    return false;
  }

  return true;
}

/**
 *
 */
void waitExit(int code)
{
#if defined(WIN32)
    Sleep(2*1000);
#else
    sleep (2);
#endif
    exit(code);
}

/**
 *
 */
void normalize(double &  x, double &  y)
{
    x = 2.0 * x / winWidth  - 1.0;
    if (x < -1.0) x = -1.0;
    if (x >  1.0) x =  1.0;

    y = -(2.0 * y / winHeight - 1.0);
    if (y < -1.0) y = -1.0;
    if (y >  1.0) y =  1.0;
}

void ScreenToWorld(double& xw, double& yw, double& zw, const int xs, const int ys)
{
  GLdouble projMatrix[16];
  GLdouble modelViewMatrix[16];
  GLint viewPort[4];

//  glMatrixMode(GL_MODELVIEW);
//  glLoadIdentity();
//  gluLookAt( eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz );
//  glMultMatrixd( trackball.get_gl_current_rotation() );
//  glRotatef(-90,1,0,0);

  glGetDoublev(GL_MODELVIEW_MATRIX, modelViewMatrix);
  glGetDoublev(GL_PROJECTION_MATRIX, projMatrix);
  glGetIntegerv(GL_VIEWPORT, viewPort);

  gluUnProject(xs, viewPort[3]-ys, 1, modelViewMatrix, projMatrix, viewPort, &xw, &yw, &zw);
}

/**
 *
 */
void mouse(int Button, int State, int Xmouse, int Ymouse)
{
  int MODIFIERS = glutGetModifiers();

  bool shiftOn = ( MODIFIERS & GLUT_ACTIVE_SHIFT ) == GLUT_ACTIVE_SHIFT;
//  bool altOn =   ( MODIFIERS & GLUT_ACTIVE_ALT )   == GLUT_ACTIVE_ALT;
  bool ctrlOn =  ( MODIFIERS & GLUT_ACTIVE_CTRL )  == GLUT_ACTIVE_CTRL;

  //---- Zoom Stuff ----------------------------------------
  if (bZoomModeOn)
  {
    GLdouble zmove = (yPixelCoord -  Ymouse);
    eyez += zoomSensitivity*zmove;
    bZoomModeOn = false;
  }
  bScaleObstacle = false;
  if (Button == GLUT_MIDDLE_BUTTON && State == GLUT_DOWN)
  {
    if (ctrlOn) {
      bScaleObstacle = State == GLUT_DOWN;
      if (bScaleObstacle)
        yScale = Ymouse;
      bZoomModeOn = false;
    }
    else {
      xPixelCoord = Xmouse;
      yPixelCoord = Ymouse;
      bZoomModeOn = true;
      bScaleObstacle = false;
    }
  }
  //---- Pan Stuff ----------------------------------------
  if (bPanModeOn)
  {
    GLdouble xmove = xPixelCoord -  Xmouse;
    GLdouble ymove = yPixelCoord -  Ymouse;
    eyex += panSensitivity*xmove;
    eyey -= panSensitivity*ymove;
    centerx += panSensitivity*xmove;
    centery -= panSensitivity*ymove;
    bPanModeOn = false;
  }
  bPanObstacle = false;
  if (shiftOn && Button == GLUT_LEFT_BUTTON)
  {
    if (ctrlOn) {
      bPanObstacle = State == GLUT_DOWN;
      if (bPanObstacle)
        ScreenToWorld(xPan, yPan, zPan, Xmouse, Ymouse);
      bPanModeOn = false;
    }
    else if (State == GLUT_DOWN) {
      xPixelCoord = Xmouse;
      yPixelCoord = Ymouse;
      bPanModeOn = true;
      bPanObstacle = false;
    }
  }
  //---- Trackball stuff ------------------------------------
  if (bTrackballModeOn)
  {
    double Xnorm = Xmouse;
    double Ynorm = Ymouse;
    normalize(Xnorm, Ynorm);
    trackball.end_drag(Xnorm, Ynorm);
    bTrackballModeOn = false;
  }
  if (!shiftOn &&  Button == GLUT_LEFT_BUTTON && State == GLUT_DOWN)
  {
    double Xnorm = Xmouse;
    double Ynorm = Ymouse;
    normalize(Xnorm, Ynorm);
    trackball.begin_drag(Xnorm, Ynorm);
    bTrackballModeOn = true;
  }
  glutPostRedisplay();
}

/**
 *
 */
void motion(int Xmouse, int Ymouse)
{
  //--- Zoom stuff -------------------------------------
  if(bZoomModeOn)
  {
    GLdouble zmove = yPixelCoord -  Ymouse;
    eyez += zoomSensitivity*zmove;
    xPixelCoord = Xmouse;
    yPixelCoord = Ymouse;
  }
  else if (bScaleObstacle) {
    const GLdouble scale = Ymouse - yScale;
    if (scale > 0)
      object->scale(1.02);
    else if (scale < 0)
      object->scale(0.98);
    yScale = Ymouse;
  }
  //--- Pan stuff --------------------------------------
  if (bPanModeOn)
  {
    GLdouble xmove = xPixelCoord -  Xmouse;
    GLdouble ymove = yPixelCoord -  Ymouse;
    eyex += panSensitivity*xmove;
    eyey -= panSensitivity*ymove;
    centerx += panSensitivity*xmove;
    centery -= panSensitivity*ymove;
    xPixelCoord = Xmouse;
    yPixelCoord = Ymouse;
  }
  else if (bPanObstacle) {
    double x, y, z;
    ScreenToWorld(x, y, z, Xmouse, Ymouse);
    object->translate(0.1*panSensitivity*vector3_type(x-xPan,y-yPan,z-zPan));
    xPan = x;
    yPan = y;
    zPan = z;
  }
  //--- Trackball stuff ----------------------------------
  if(bTrackballModeOn)
  {
    double Xnorm = Xmouse;
    double Ynorm = Ymouse;
    normalize(Xnorm, Ynorm);
    trackball.drag(Xnorm, Ynorm);
  }

  glutPostRedisplay();
}

/**
 *
 */
void reshape(int width, int height)
{
  winWidth = width;
  winHeight = height;

  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  aspect = (1.0*winWidth)/winHeight;
  gluPerspective( fovy, aspect, zNear, zFar);
  glViewport(0, 0, winWidth, winHeight);
  //trackball.setRadius(...)
  glutPostRedisplay();
}

/**
 *
 */
void cleanExit(unsigned char k)
{
  //glutDestroyWindow(mainWindow);
  if (k == 'q')
  {
    waitExit(0);
  }
  exit(0);
}

/**
 *
 */
void idle()
{
  if (emitter) emitter->execute();
  if (waves) {
    vector3_type ext = DBb2.ext();
    vector3_type cen = DBb2.center();
    static double t = 0;
    using std::fabs;
    const double w = 0.1*fabs(sin(t));
    ext(0) = 0.5+w; t += 0.05;
    cen(0) = 0.3125+w;
    DBb2.set(cen, DBb2.orientation(), ext);
  }
//  for (int n = 0; n < 10; ++n) sph->simulate();
  sph->simulate();

  glutPostRedisplay();
/*
//  if (emitter && !emitter->active())
  if (fps.frame())
    cout << "[" << test_pars << "] particles - FPS: " << fps() << endl;
*/
}

/**
 *
 */
void key(unsigned char k, int /*x*/, int /*y*/)
{
  switch (k)
  {
  case 27:
  case 'q':
#ifdef WIN32
    if(pMovie)
    {
      pMovie->EndCapture();
      delete pMovie;
    }
#endif
    cleanExit(k);
    break;
  case ' ':
    if (!sph) break;
    idleOn = !idleOn;
    if(idleOn)
    {
      cout << "Starting simulation" << endl;
      glutIdleFunc(idle);
    }
    else
    {
      cout << "Stopping simulation" << endl;
      glutIdleFunc(0);
    }
    break;
  case 'y':
    screenCapture = true;
    //screenCapture = !screenCapture;
    break;
#ifdef WIN32
  case 'M':
  {
    static int movieCount = 0;
    bMovieOn = !bMovieOn;
    if(bMovieOn)
    {
      stringstream movieName;
      movieName << "movie_" << movieCount++ << ".avi";
      pMovie = new MovieMaker;
      pMovie->StartCapture(movieName.str().c_str());
    }
    else
    {
      pMovie->EndCapture();
      delete pMovie;
      pMovie = NULL;
    }
    break;
  }
#endif
  case 'n':
  case 'N':
    draw_normals = !draw_normals;
    break;
  case 'v':
  case 'V':
    draw_velocity = !draw_velocity;
    break;
  case 'w':
  case 'W':
    waves = !waves;
    break;
  case 's':
  case 'S':
    draw_surface = !draw_surface;
    break;
  case 'i':
  case 'I':
    draw_inside = !draw_inside;
    break;
  case 'o':
  case 'O':
    osd = !osd;
    break;
  case 'r':
  case 'R':
    render = !render;
    break;
  case 'c':
    if (sph) sph->collisionSystem().clear();
    if (object == &capsule)
      addCollisionObject(&sphere);
    else if (object == &sphere)
      addCollisionObject(&box);
    else
      addCollisionObject(&capsule);
    break;
  case 'C':
    if (++obstacles > 2)
      obstacles = 0;
    break;
  case 'E':
    use_emitter = !use_emitter;
    break;
  case 'e':
    if (!emitter) break;
    if (emitter->running())
      emitter->stop();
    else
      emitter->start();
    break;
  case '1':
    // create small water
    createFluid<WaterMaterial>(500);
//    test_pars *= 2;
//    if (!test_pars) test_pars = 100;
//    test_pars += 100;
//    createFluid<WaterMaterial>(test_pars);
    break;
/*
  case '!':
    // create small water
    createFluid<WaterMaterial>(test_pars);
    break;
*/
  case '2':
    // create medium water
    createFluid<WaterMaterial>(1250);//1500
    break;
  case '3':
    // create medium water
    createFluid<WaterMaterial>(2250);
    break;
  case '4':
    // create large water
    createFluid<WaterMaterial>(4400);
    break;
  case '5':
    // create small mucus
    createFluid<MucusMaterial>(500);
//    test_pars += 100;
//    createFluid<MucusMaterial>(test_pars);
    break;
  case '6':
    // create medium mucus
    createFluid<MucusMaterial>(1250);//1500
    break;
  case '7':
    // create medium mucus
    createFluid<MucusMaterial>(2250);
    break;
  case '8':
    // create large mucus
    createFluid<MucusMaterial>(4400);
    break;
  case '0':
    // create test steam
    createFluid<SteamMaterial>(2000);
    break;
  case '.':
  {
    const double a = 45*Math::details::degree<double>(), b = 0*Math::details::degree<double>(), c = 0*Math::details::degree<double>();
    object->rotate(Volume::matrix3x3_type(1,0,0, 0,cos(a),sin(a), 0,-sin(a),cos(a)));
    object->rotate(Volume::matrix3x3_type(cos(b),0,-sin(b), 0,1,0, sin(b),0,cos(b)));
    object->rotate(Volume::matrix3x3_type(cos(c),sin(c),0, -sin(c),cos(c),0, 0,0,1));
    break;
  }
  case ',':
  {
    const double a = -2*Math::details::degree<double>(), b = -2*Math::details::degree<double>(), c = -2*Math::details::degree<double>();
    object->rotate(Volume::matrix3x3_type(1,0,0, 0,cos(a),sin(a), 0,-sin(a),cos(a)));
    object->rotate(Volume::matrix3x3_type(cos(b),0,-sin(b), 0,1,0, sin(b),0,cos(b)));
    object->rotate(Volume::matrix3x3_type(cos(c),sin(c),0, -sin(c),cos(c),0, 0,0,1));
    break;
  }
  case '+':
    if (sph) {
      sph->collisionSystem().clear();
      sph->collisionSystem().addContainer(iDBb2); object = &DBb2;
    }
    break;
  case '-':
    if (sph) {
      sph->collisionSystem().clear();
      sph->collisionSystem().addContainer(iDBb1); object = &DBb1;
    }
    break;
  default:
    break;
  }

  glutPostRedisplay();
}

void renderSurface(const DefaultSystem::fluid_material* mat, const SPHTypes::real_type& size)
{
  typedef SPHTypes::real_type   real_type;
  typedef vector3_type vector3_type;
  // find BB of fluid (for high res rendering)
  vector3_type  m( Math::highest<real_type>() ), M( Math::lowest<real_type>() );

  const SPHTypes::particle_container &pars = sph->particles();
  SPHTypes::particle_container::const_iterator pars_end = pars.end();
  for (SPHTypes::particle_container::const_iterator p = pars.begin(); p != pars_end; ++p)
  {
    vector3_type const & pos = p->position();
    M = max(M, pos);
    m = min(m, pos);
  }
  real_type const d = 1.35*pow((3.*mat->particle_mass())/(4.*Math::details::pi<real_type>()*mat->density()), 1./3.);
  m -= vector3_type(d);
  M += vector3_type(d);
  
  vector3_type v((M-m)/size);
  v = ceil(v);

  if(phi.I()<v(0) ||  phi.J()<v(1)  || phi.K()<v(2))
    phi.create( m ,M
                 , static_cast<math_types::idx_type>(v[0])
                 , static_cast<math_types::idx_type>(v[1])
                  , static_cast<math_types::idx_type>(v[2])
                  ); // TODO 2005-08-28 KE: hmmm, this should be pre-allocated!!!

  Map<double,math_types>::index_iterator phi_begin = phi.begin();
  Map<double,math_types>::index_iterator phi_end = phi.end();
  for(Map<double,math_types>::index_iterator phi_ = phi_begin; phi_ != phi_end; ++phi_)
    *phi_ = 0.;

/*
  SPHTypes::particle_container::const_iterator par = pars.begin();
  SPHTypes::particle_container::const_iterator par_end = pars.end();
  for (;par!=par_end;++par)
  {
    const vector3_type& n = par->normal();
    const SPHTypes::real_type l = n*n;
    if (l >= mat->threshold() || l < 0.0025)
    {
      const vector3_type &r = par->position();
      unsigned int i = static_cast<unsigned int>(std::floor( (r(0) - phi.minCoord(0)) / phi.dx() ));
      unsigned int j = static_cast<unsigned int>(std::floor( (r(1) - phi.minCoord(1)) / phi.dy() ));
      unsigned int k = static_cast<unsigned int>(std::floor( (r(2) - phi.minCoord(2)) / phi.dz() ));
      phi(  i,  j,k) = 100;
      phi(  i,j+1,k) = 100;
      phi(i+1,  j,k) = 100;
      phi(i+1,j+1,k) = 100;
      phi(  i,  j,k+1) = 100;
      phi(  i,j+1,k+1) = 100;
      phi(i+1,  j,k+1) = 100;
      phi(i+1,j+1,k+1) = 100;
    }
  }
*/

  Map<double,math_types>::vector3_type coord;
  for(Map<double,math_types>::index_iterator phi_ = phi_begin; phi_ != phi_end; ++phi_)
  {
//    if(*phi_>1.)
    {
      map_idx2coord(phi_,coord);
      *phi_ = sph->isoValue(coord);//0.35 - sph->isoValue(pos);
    }
  }


  //mesh::isosurface(phi,0.0,surface);
  mesh::smooth_isosurface(phi,0.6,surface,1,true);

//  polymesh::PolyMesh<>::vertex_iterator end = surface.vertex_end();
//  for (polymesh::PolyMesh<>::vertex_iterator vtx = surface.vertex_begin(); vtx != end; ++vtx)
//    vtx->m_color = polymesh::PolyMesh<>::vector3_type(mat->red(), mat->green(), mat->blue());

  glColor3d(mat->red(), mat->green(), mat->blue());
//  glEnableClientState(GL_VERTEX_ARRAY);
//  glEnableClientState(GL_NORMAL_ARRAY);

  glEnable(GL_LIGHTING);
  glEnable(GL_COLOR_MATERIAL);
    glEnable(GL_CULL_FACE);
  glCullFace(GL_BACK);

  GL::DrawMesh(surface, GL_POLYGON, false, true, false);
//  MeshDrawArray<PolyMesh<> > dm(surface);
//  dm();
  //GL::DrawMesh(surface);

  //char *vertexArray = (char *) surface.getVertexArray();
  //glVertexPointer(3, GL_FLOAT, sizeof(ISvertex), vertexArray);
  //glNormalPointer(   GL_FLOAT, sizeof(ISvertex), vertexArray + sizeof(ISvec3));
  //glDrawElements(GL_TRIANGLES, surface.getIndexCount(), GL_UNSIGNED_INT, surface.getIndexArray());

//  glDisableClientState(GL_NORMAL_ARRAY);
//  glDisableClientState(GL_VERTEX_ARRAY);

  // draw bb
#if 0
  glDisable(GL_LIGHTING);
  glColor3d(0,0,0);
  glBegin(GL_LINES);
    glVertex3d(m[0], m[1], m[2]);
    glVertex3d(M[0], m[1], m[2]);
    glVertex3d(M[0], m[1], m[2]);
    glVertex3d(M[0], M[1], m[2]);
    glVertex3d(M[0], M[1], m[2]);
    glVertex3d(m[0], M[1], m[2]);
    glVertex3d(m[0], M[1], m[2]);
    glVertex3d(m[0], m[1], m[2]);
    glVertex3d(m[0], m[1], M[2]);
    glVertex3d(M[0], m[1], M[2]);
    glVertex3d(M[0], m[1], M[2]);
    glVertex3d(M[0], M[1], M[2]);
    glVertex3d(M[0], M[1], M[2]);
    glVertex3d(m[0], M[1], M[2]);
    glVertex3d(m[0], M[1], M[2]);
    glVertex3d(m[0], m[1], M[2]);
    glVertex3d(m[0], m[1], m[2]);
    glVertex3d(m[0], m[1], M[2]);
    glVertex3d(M[0], m[1], m[2]);
    glVertex3d(M[0], m[1], M[2]);
    glVertex3d(M[0], M[1], m[2]);
    glVertex3d(M[0], M[1], M[2]);
    glVertex3d(m[0], M[1], m[2]);
    glVertex3d(m[0], M[1], M[2]);
  glEnd();
#endif
/*
  glEnable(GL_LIGHTING);
  for (SPHTypes::real_type k = m[2]; k < M[2]; k += size)
    for (SPHTypes::real_type j = m[1]; j <= M[1]; j += size)
      for (SPHTypes::real_type i = m[0]; i <= M[0]; i += size) {
        vector3_type test(i+.5*size, j+.5*size, k+.5*size);
        if ((0.35-sph->isoValue(test)) <= 0) {
          glBegin(GL_QUADS);
            glColor3d(1,0,0);
            glNormal3d(1, 0, 0);
            glVertex3d(i, j, k);
            glVertex3d(i, j+size, k);
            glVertex3d(i, j+size, k+size);
            glVertex3d(i, j, k+size);
            glColor3d(0,1,0);
            glNormal3d(0, 1, 0);
            glVertex3d(i, j, k);
            glVertex3d(i+size, j, k);
            glVertex3d(i+size, j, k+size);
            glVertex3d(i, j, k+size);
            glColor3d(0,0,1);
            glNormal3d(0, 0, 1);
            glVertex3d(i, j, k);
            glVertex3d(i+size, j, k);
            glVertex3d(i+size, j+size, k);
            glVertex3d(i, j+size, k);
          glEnd();
        }
      }
*/
  glDisable(GL_COLOR_MATERIAL);
  glDisable(GL_CULL_FACE);
}

void renderParticles(const DefaultSystem::fluid_material* mat)
{
    GLUquadric * qobj = gluNewQuadric();
    gluQuadricDrawStyle(qobj, GLU_FILL);
    glEnable(GL_COLOR_MATERIAL);
    glDisable(GL_LIGHTING);

//    unsigned long cnt = 0;
    const SPHTypes::particle_container &pars = sph->particles();
    for (SPHTypes::particle_container::const_iterator p = pars.begin(); p != pars.end(); p++) {
      if (p->fixed()) continue;
      const vector3_type &pos = p->position();

      //
      // V = 4/3 pi r^3  =>  m/rho = 4/3 pi r^3  =>  r^3 = (3 m)/(4 pi rho)  =>  r = ((3 m)/(4 pi rho))^1/3
      //
      const SPHTypes::real_type d = 0.9*pow((3.*p->mass())/(4.*Math::details::pi<real_type>()*p->density()), 1./3.);
      const vector3_type& n = p->normal();
      const SPHTypes::real_type l = n*n;

      bool draw_sphere = false;
      if (l >= mat->threshold() || l < 0.0025) {
        // draw surface normals
        if (draw_normals && l >= mat->threshold()) {
          const vector3_type sn = -0.05*unit(n);
          glColor3d(0.5, 0.5, 0.5);
          glBegin(GL_LINES);
          glVertex3d(pos[0], pos[1], pos[2]);
          glVertex3d(pos[0]+sn[0], pos[1]+sn[1], pos[2]+sn[2]);
          glEnd();
        }
        glColor3d(mat->red(), mat->green(), mat->blue());
        draw_sphere = draw_surface;
      }
      else {
        glColor3d(.5*mat->red(), .5*mat->green(), .5*mat->blue());
        draw_sphere = draw_inside;
      }

      // default behaviour
      if (!(draw_surface || draw_inside)) {
        glColor3d(mat->red(), mat->green(), mat->blue());
        draw_sphere = true;
      }
#if 0
      draw_sphere = !(draw_surface || draw_inside);
      if (cnt++ > 1200 && cnt < 1211)
        draw_sphere = true;
#endif
      if (draw_velocity) {
        glEnable(GL_LIGHTING);
        const vector3_type vel = 0.05*p->velocity();
        GL::DrawVector(pos, vel, 1, false);
      }
      else if (draw_sphere) {
        glPushMatrix();
        glTranslated(pos[0], pos[1], pos[2]);
        glEnable(GL_LIGHTING);
        gluSphere(qobj, d, 8, 8);
        glDisable(GL_LIGHTING);
        glPopMatrix();
      }

    }
    gluDeleteQuadric(qobj);
}

/**
 * Put text onto screen (OSD)
 */
void putText(const double &x, const double &y, const double &r, const double &g, const double &b, const string &text)
{
  // setup orthogonal projection to use 2D text
  glMatrixMode(GL_PROJECTION);
  glPushMatrix();
  glLoadIdentity();
  glViewport(0, 0, winWidth, winHeight);
  glOrtho(0, winWidth, 0, winHeight, 0, 1);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  glDisable(GL_TEXTURE_2D);

  glColor4d(r, g, b, 1);
  glRasterPos2i( static_cast<int>( x ), static_cast<int>( y ) );
  for (const char *c = text.c_str(); *c != '\0'; ++c)
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, *c);//GLUT_BITMAP_8_BY_13
  glColor4d(r+.5, g+.5, b+.5, 1);
  glRasterPos2i( static_cast<int>( x+1 ), static_cast<int>( y-1 ) );
  for (const char *c = text.c_str(); *c != '\0'; ++c)
    glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, *c);//GLUT_BITMAP_8_BY_13

  glMatrixMode(GL_PROJECTION);
  glPopMatrix();
}

/**
 *
 */
void display()
{
  glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();
  gluLookAt( eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz );
  glMultMatrixd( trackball.get_gl_current_rotation() );
  glRotatef(-90,1,0,0);

#ifdef DRAW_KERNELS
  glRotatef(90,1,0,0);
  const unsigned long dots = 200;
  Radius = 1.;

#ifdef USE_GAUSSIAN
  KernelGaussian W;
  const SPHTypes::real_type Yscale = 14;  // gaussian
#else
  KernelDefault W;
  const SPHTypes::real_type Yscale = 0.25;  // poly6

//  KernelPressure W;
//  const SPHTypes::real_type Yscale = 0.1;  // spiky

//  KernelViscosity W;
//  const SPHTypes::real_type Yscale = 0.9;  // viscosity
#endif

  glEnable(GL_LIGHTING);
  glEnable(GL_COLOR_MATERIAL);
  GLUquadric * qobj = gluNewQuadric();
  gluQuadricDrawStyle(qobj, GLU_FILL);

  // kernel (grey)
  glColor3d(0.2, 0.2, 0.2);
  for (unsigned long n = 0; n <= dots; n++) {
    const SPHTypes::real_type x = -3.+(6.*n)/dots;
    const vector3_type r(x,0,0);
    const SPHTypes::real_type y = W.evaluate(r);
    glPushMatrix();
    glTranslated(x*2, y*2*Yscale, 0);
    gluSphere(qobj, 0.05, 8, 8);
    glPopMatrix();
  }

  // gradient (blue)
  glColor3d(0.2, 0.2, 0.8);
  for (unsigned long n = 0; n <= dots; n++) {
    const SPHTypes::real_type x = -3.+(6.*n)/dots;
    const vector3_type r(x,0,0);
#ifdef USE_GAUSSIAN
    const vector3_type y = W.gradient(r);
#else
    const vector3_type y = fabs(W.gradient(r));
#endif
    glPushMatrix();
    glTranslated(x*2, y[0]*2*Yscale, 0);
    gluSphere(qobj, 0.05, 8, 8);
    glPopMatrix();
  }

  // laplacian (red)
  glColor3d(0.8, 0.2, 0.2);
  for (unsigned long n = 0; n <= dots; n++) {
    const SPHTypes::real_type x = -3.+(6.*n)/dots;
    const vector3_type r(x,0,0);
#ifdef USE_GAUSSIAN
    const SPHTypes::real_type y = W.laplacian(r);
#else
    const SPHTypes::real_type y = 0.1*W.laplacian(r);
#endif
    glPushMatrix();
    glTranslated(x*2, y*2*Yscale, 0);
    gluSphere(qobj, 0.05, 8, 8);
    glPopMatrix();
  }

  gluDeleteQuadric(qobj);
#else

  if (obstacles) {
    glEnable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
    glColor3d(0.5, 0.0, 0.3);
    const GLenum mode = 1==obstacles?GL_LINE_LOOP:GL_POLYGON;
    object->draw( mode );
    glDisable(GL_LIGHTING);
  }

#if 0
    GLdouble plane[4];
    plane[0] = 0;
    plane[1] = 1;
    plane[2] = 0;
    plane[3] = 0.6;
    glClipPlane(GL_CLIP_PLANE0,plane);
    glEnable(GL_CLIP_PLANE0);

    glEnable(GL_COLOR_MATERIAL);
    glEnable(GL_LIGHTING);
    const GLenum mode = 1==obstacles?GL_LINE_LOOP:GL_POLYGON;
    otgDrawT4Mesh(points, shell, obstacles?1.:0.9, mode);
    glDisable(GL_LIGHTING);

    glDisable(GL_CLIP_PLANE0);
#endif

  if (use_emitter && emitter) {
    glDisable(GL_COLOR_MATERIAL);
    glDisable(GL_LIGHTING);
    if (emitter->active()) {
      if (emitter->running())
        glColor3d(0.1, 0.9, 0.1);
      else
        glColor3d(0.9, 0.1, 0.1);
    }
    else
      glColor3d(0.2, 0.2, 0.2);
    const vector3_type& c = emitter->center();
    const SPHTypes::real_type x = .03;

    glBegin(GL_LINES);
      glVertex3d(c(0)-x,c(1)-x,c(2)-x);
      glVertex3d(c(0)+x,c(1)-x,c(2)-x);

      glVertex3d(c(0)+x,c(1)-x,c(2)-x);
      glVertex3d(c(0)+x,c(1)+x,c(2)-x);

      glVertex3d(c(0)+x,c(1)+x,c(2)-x);
      glVertex3d(c(0)-x,c(1)+x,c(2)-x);

      glVertex3d(c(0)-x,c(1)+x,c(2)-x);
      glVertex3d(c(0)-x,c(1)-x,c(2)-x);

      glVertex3d(c(0)-x,c(1)-x,c(2)+x);
      glVertex3d(c(0)+x,c(1)-x,c(2)+x);

      glVertex3d(c(0)+x,c(1)-x,c(2)+x);
      glVertex3d(c(0)+x,c(1)+x,c(2)+x);

      glVertex3d(c(0)+x,c(1)+x,c(2)+x);
      glVertex3d(c(0)-x,c(1)+x,c(2)+x);

      glVertex3d(c(0)-x,c(1)+x,c(2)+x);
      glVertex3d(c(0)-x,c(1)-x,c(2)+x);

      glVertex3d(c(0)-x,c(1)-x,c(2)-x);
      glVertex3d(c(0)-x,c(1)-x,c(2)+x);

      glVertex3d(c(0)+x,c(1)-x,c(2)-x);
      glVertex3d(c(0)+x,c(1)-x,c(2)+x);

      glVertex3d(c(0)+x,c(1)+x,c(2)-x);
      glVertex3d(c(0)+x,c(1)+x,c(2)+x);

      glVertex3d(c(0)-x,c(1)+x,c(2)-x);
      glVertex3d(c(0)-x,c(1)+x,c(2)+x);
    glEnd();
  }

/*
  // draw WCS (RGB) = (XYZ)
  glBegin(GL_LINES);
    glColor3d(.9,.1,.1);
    glVertex3d(0,0,0);
    glVertex3d(1,0,0);
    glColor3d(.1,.9,.1);
    glVertex3d(0,0,0);
    glVertex3d(0,1,0);
    glColor3d(.1,.1,.9);
    glVertex3d(0,0,0);
    glVertex3d(0,0,1);
  glEnd();
*/

  const DefaultSystem::fluid_material* mat = sph?sph->material():NULL;
  if (sph) {

    if (render)
      renderSurface(mat, 0.02);
    else
      renderParticles(mat);

    // MESH COLI TEST
/*
    glDisable(GL_LIGHTING);
    glColor3d(1.0, 0.0, 0.6);
    const CollisionDetection::ColiDebug& dcoli = sph->collisionSystem().dcoli;
    if (dcoli.t4) {
      Tetrahedron T(dcoli.i, dcoli.j, dcoli.k, dcoli.m);
      T.scale(0.8);
      T.draw(GL_POLYGON);

      //Triangle t(dcoli.j, dcoli.k, dcoli.m);
      //Triangle t(dcoli.i, dcoli.j, dcoli.m);
      Triangle t(dcoli.k, dcoli.i, dcoli.m);
      //Triangle t(dcoli.i, dcoli.k, dcoli.j);
      glColor3d(1.0, 1.0, 0.2);
      t.draw(GL_POLYGON);

      vector3<double> x0, x1;

      glColor3d(0.5, 0.5, 0.1);
      glBegin(GL_LINES);
        x0 = t.center();
        x1 = t.center()+0.2*t.normal();
        glVertex3d(x0[0], x0[1], x0[2]);
        glVertex3d(x1[0], x1[1], x1[2]);
      glEnd();

      glColor3d(0, 0, 0);
      glBegin(GL_LINES);
        x0 = dcoli.p0;
        x1 = dcoli.p1;//dcoli.p0+unit(dcoli.p1-dcoli.p0);//dcoli.p0+0.2*(unit(dcoli.p1-dcoli.p0));
        glVertex3d(x0[0], x0[1], x0[2]);
        glVertex3d(x1[0], x1[1], x1[2]);
      glEnd();

    }
*/
  }

  fps.frame(); // probe both sim + vis
  if (osd) {
    glDisable(GL_LIGHTING);
    stringstream ss;
    ss << "FPS: " << setw(4) << fps();
    putText(winWidth-70, winHeight-30, 0.15, 0.0, 0.05, ss.str());
    ostringstream ost;
    ost << "Material: " << (mat?mat->name():"N/A");
    putText(16, winHeight-30, 0.15, 0.0, 0.05, ost.str());
    ost.str("");
    ost << "Particle Mass [kg]: " << (mat?mat->particle_mass():0.);
    putText(16, winHeight-50, 0.15, 0.0, 0.05, ost.str());
    ost.str("");
    ost << "Volume [m3]: " << (mat?mat->volume():0.);
    putText(16, winHeight-70, 0.15, 0.0, 0.05, ost.str());
    ost.str("");
    ost << "Particles: " << (mat?mat->particles():0.);
    putText(16, winHeight-90, 0.15, 0.0, 0.05, ost.str());
  }

#endif

  if(screenCapture)
  {
    ostringstream filename;
    static int frmno = 0;
    filename << "screen_" << setfill('0') << setw(4) << frmno++ << ".png";
    image_write(filename.str(), *screen_capture() );
    screenCapture = false;
  }

  glFinish();

  glutSwapBuffers();
  glutPostRedisplay();

#ifdef WIN32
  if(bMovieOn)
    pMovie->Snap();
#endif
}

/**
 *
 */
void menu(int entry)
{
  key(entry, 0, 0);
}

/**
 *
 */
int main(int argc, char **argv)
{
  glutInit(&argc, argv);
#if 0
  const char* dt_env = getenv("DATATISSUE");
  if (!dt_env)
  {
    cout << "Get outta here,\nand DON'T come back before you've defined the DATATISSUE environment variable!" << endl;
    return 0;
  }
  string data_path = string(dt_env) + "/demos/opengl/fluids/";
#endif

#if 0
  if (!TMesh2T4Mesh(data_path+"capsule.msh", data_path+"capsule.dat"))
  {
    cout << "Ohhh, crap!" << endl;
  }
  return 0;
#endif

  glutInitDisplayMode(GLUT_RGBA | GLUT_DEPTH | GLUT_DOUBLE);
  glutInitWindowSize(winWidth, winHeight);
  glutInitWindowPosition(50, 50);
  mainWindow = glutCreateWindow("Lagrangian Fluid Dynamics (SPH)");

  //glClearColor(0.7,0.7,0.7,0);
  glClearColor(1.,1.,1.,0);
  glEnable(GL_DEPTH_TEST);
  glEnable(GL_NORMALIZE);
  glFrontFace(GL_CCW);

  //--- Set up Antialiasing

  //glEnable(GL_LINE_SMOOTH);
  //glEnable(GL_POLYGON_SMOOTH);

  //--- Set up Lights

  glEnable(GL_LIGHTING);
  glEnable(GL_LIGHT0);
  //glEnable(GL_LIGHT1);
  // light_position is NOT a default value
  // 4th component == 1 means at finite position,
  //               == 0 means at infinity

  // Shading Model

  glShadeModel(GL_SMOOTH);
  glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE);
  glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);

  // light_position is NOT a default value
  // 4th component == 1 means at finite position,
  //               == 0 means at infinity
  //GLfloat LightPosition[] = { 1.0, 1.0, 1.0, 0.0 };
  GLfloat LightPosition[] = { 1.0, 10.0, 1.0, 1.0 };

  GLfloat AmbientLight[]  = { .2, .2, .2, 1.0 };

  GLfloat DiffuseLight[]  = { .9, .9, .9, 1.0 };

  GLfloat SpecularLight[] = { 1.0, 1.0, 1.0, 1.0 };
  glLightfv(GL_LIGHT0, GL_POSITION, LightPosition);
  glLightfv(GL_LIGHT0, GL_AMBIENT,  AmbientLight);
  glLightfv(GL_LIGHT0, GL_DIFFUSE,  DiffuseLight);
  glLightfv(GL_LIGHT0, GL_SPECULAR, SpecularLight);

  //GLfloat LightPosition1[] = { -1.0, 1.0, 1.0, 0.0 };
  //glLightfv(GL_LIGHT1, GL_POSITION, LightPosition1);
  //glLightfv(GL_LIGHT1, GL_AMBIENT,  AmbientLight);
  //glLightfv(GL_LIGHT1, GL_DIFFUSE,  DiffuseLight);
  //glLightfv(GL_LIGHT1, GL_SPECULAR, SpecularLight);

  //--- Setup right mouse button popup menu system
  int mainMenu = glutCreateMenu(menu);

  int toggles = glutCreateMenu(menu);
  glutAddMenuEntry("Animation [ ]", ' ');
  glutAddMenuEntry("On Screen Display [o]", 'o');
  glutAddMenuEntry("Render Surface [r]", 'r');
  glutAddMenuEntry("Surface Particles [s]", 's');
  glutAddMenuEntry("Intrinsic Particles [i]", 'i');
  glutAddMenuEntry("Surface Normals [n]", 'n');
  glutAddMenuEntry("Velocities [v]", 'v');
  glutAddMenuEntry("View Collision Objects [C]", 'C');
  glutAddMenuEntry("Change Collision Objects [c]", 'c');
  glutAddMenuEntry("Emitter [E]", 'E');
  glutAddMenuEntry("Start/Stop Emitter [e]", 'e');
  glutAddMenuEntry("Dam-Break: Init Dam [-]", '-');
  glutAddMenuEntry("Dam-Break: Break Dam [+]", '+');
  glutAddMenuEntry("Start/Stop Box Waves [w]", 'w');

  int materials = glutCreateMenu(menu);
  glutAddMenuEntry("Water  (500) [1]", '1');
  glutAddMenuEntry("Water (1250) [2]", '2');
  glutAddMenuEntry("Water (2250) [3]", '3');
  glutAddMenuEntry("Water (4400) [4]", '4');
  glutAddMenuEntry("Mucus  (500) [5]", '5');
  glutAddMenuEntry("Mucus (1250) [6]", '6');
  glutAddMenuEntry("Mucus (2250) [7]", '7');
  glutAddMenuEntry("Mucus (4400) [8]", '8');
  glutAddMenuEntry("Steam (test) [0]", '0');

  glutSetMenu(mainMenu);
  glutAddSubMenu("toggles", toggles);
  glutAddSubMenu("materials", materials);
  glutAddMenuEntry("Screen Capture [y]", 'y');
#ifdef WIN32
  glutAddMenuEntry("Record movie [M]", 'M' );
#endif
  glutAddMenuEntry("quit [esc]", 27);
  glutAttachMenu(GLUT_RIGHT_BUTTON);

  //--- Setup call back functions
  if(idleOn)
    glutIdleFunc(idle);
  glutDisplayFunc(display);

  glutReshapeFunc(reshape);
  glutMouseFunc(mouse);
  glutMotionFunc(motion);
  glutKeyboardFunc(key);

  glutMainLoop();

  return 0;
}
